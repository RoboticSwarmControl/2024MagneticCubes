\chapter{Global Planner}
\label{chap:global}

The task of the global planner is to assemble a specified target polyomino $\mathcal{T}$ given an initial configuration $g_\textit{init}$.
The configuration-space is explored by executing local plans developed by the local planner from \autoref{chap:local}.
That way, the configuration-space is limited to configurations where a connection between two cubes was attempted.
Since the number of cubes is limited, there is a finite set of local plans leading to new configurations.
Compared to $\textit{SE}(2)$, the part of the configurations-space explored by our global planner only contains configurations which are relevant for self-assembly.

Determining how these configurations are explored affects the run time considerably.
Using rapidly-exploring random trees (RRTs) \cite{lavalle1998} yields good results in many cases.
The configuration-space gets evenly explored without the challenge of determining what decisions are promising for the end goal.
This also means that most of the explored configurations are not relevant for reaching the goal.
For us this approach is not reasonable, because of the high fidelity simulator we are working with.

Computation time for a local plan is huge, so planning the assembly of $\mathcal{T}$ with as few local plans as possible is the aim for our global planner.
We need to make well-thought-through connection decisions that are valid for assembling $\mathcal{T}$, meaning some sort of building plan for a polyomino is needed.
Creating a building sequence by removing one tile at a time from the target was done by Becker et al.\ \cite{Becker2020}.
However, this does not consider sub-assemblies, so all cubes that are not to be connected have to stay separated at any time.

It is hard to prevent sub-assemblies with magnetic cubes following the rules of the Tilt model \cite{Becker2014_SP}.
Our approach uses an enumeration of ways to cut a polyomino into two parts (\autoref{sec:twocutting}), which will be used for generating a so-called two-cut-sub-assembly graph (\autoref{sec:tcsa}).
This graph functions as a building instruction alongside the exploration of the configuration-space.
\autoref{sec:connect_options} provides a closer look on the use of this graph for decision-making and \autoref{sec:local_in_global} further explains the usage of the local planner on a global scale. 
Finally, \autoref{sec:global_algo} combines previous techniques to a global planning algorithm.
For the algorithm the number of cubes in the workspace is limited to the size of $\mathcal{T}$.
An explanation on why is this done and why the problem becomes more complex when working with extra cubes is provided in \autoref{sec:more_cubes}.

\begin{figure}
	\centering
	\includegraphics[width=0.55\textwidth]{figures/twocuts.pdf}
	\caption[Different cuts for polyomino shapes]{Examples for cutting polyomino shapes. a) to d) show four two-cuts of which only a) and d) are monotone and therefore valid. b) creates a cave and c) a hole. e) and f) show cuts that do not split the polyomino shapes into two pieces. e) does not break the polyomino at all and f) creates three sub-polyominoes.}
	\label{fig:twocuts}
\end{figure}

\section{Two-Cutting Polyominoes}
\label{sec:twocutting}

Schmidt et al.\ \cite{Schmidt2018} made use of straight-line two-cuts, to handle the construction of a polyomino with more than trivial sub-assemblies.

We define a \textit{two-cut} as a continuous edge path through a polyomino that would divide the polyomino into two sub-polyominoes, if all connections with these edges are removed.
For later use in \autoref{sec:tcsa}, an enumeration of all two-cuts of a polyomino that are useful for planning is needed.
We do not limit the cuts by only allowing straight paths like Schmidt et al.\ \cite{Schmidt2018}, instead we only consider monotone two-cuts.

\textit{Monotone} means that whenever the path goes into a certain direction, it can never go into the opposite direction again.
\autoref{fig:twocuts} a) and d) show examples of monotone two-cuts.
The paths start at the top of the shape and only move down and right.
By removing all the connections on these paths, the polyomino shapes are split into two pieces.
Considering non-monotone two-cuts would create sub-assemblies with caves or holes, which could not be reassembled with our local planner.
For this reason, they are omitted on a global scale in advance.
\autoref{fig:twocuts} b) shows a non-monotone two-cut creating a cave and \autoref{fig:twocuts} c) shows one creating a hole.

To calculate all two-cuts of a polyomino, we take all possible monotone paths from each connection as a starting point.
A path ends when it breaks out of the polyomino.
After the path ended, the connections at its edges are removed and the path is added as a two-cut, if the polyomino got split into exactly two pieces.
\autoref{fig:twocuts} e) and f) show cuts that do not split the polyomino, or split the polyomino in more than two pieces.

% 32 possibilities for 3x3
\newpage

\section{Two-Cut-Sub-Assembly Graph}
\label{sec:tcsa}

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{figures/tcsa.pdf}
	\caption[Example of a two-cut-sub-assembly graph]{Example of a two-cut-sub-assembly graph for a four-cube L-shape. The polyomino sets are illustrated as ellipses. If the polyominoes of a set are not numbered, there is only one occurrence of this polyomino. Otherwise the number of occurrences is placed left of the polyomino. The sets are numbered as if the graph was produced by \autoref{algo:build_tcsa} starting from $S_\mathcal{T}$. The weights of edges are illustrated as rectangular boxes containing the polyominoes that need to be connected at specific edge paths, marked in yellow.}
	\label{fig:tcsa}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.4\textwidth]{figures/tcsa_multiedge.pdf}
	\caption[Two-cut-sub-assembly nodes connected with multiple edges]{Two two-cut-sub-assembly edges connecting the polyomino sets $S_0$ and $S_1$. The weights of the edges differ, since there are two ways to connect the $2\times1$ with the $1\times1$ to create the $3\times1$ polyomino. The connections are illustrated in rectangular boxes placed on the edges.}
	\label{fig:tcsa_multiedge}
\end{figure}

The two-cut-sub-assembly graph, abbreviated as TCSA graph, functions as a building instruction for a specific target polyomino.
For a target polyomino $\mathcal{T}$, we will call it $G_{\textit{TCSA}}(\mathcal{T}) = \{V,E\}$ represented by nodes $V$ and edges $E$.

The TCSA graph works with sets of polyominoes as nodes.
While a configuration $g$ holds information about orientation and position of physically distinct polyominoes, the corresponding polyomino set $S(g)$ only enumerates the polyomino types present in $g$.
If $g$ contains multiple polyominoes of the same type, $S(g)$ still stores the amount of the polyomino type, but does not distinguish between the actual polyominoes.

Two nodes $S_0$ and $S_1$ of the TSCA graph are connected with an edge $\{S_0,t_c,S_1\}$ if $S_0$ can be transformed to $S_1$ by connecting two polyominoes contained in $S_0$.
The edge path specifying this connection is stored as the weight $t_c$.
$S_0$ and $S_1$ can be connected by multiple edges, if there are different connections that produce the same outcome.
The edges differ in their weights as shown in \autoref{fig:tcsa_multiedge}.
The direction of $\{S_0,t_c,S_1\}$ always goes from $S_0$ to $S_1$, but we can reverse the definition for an edge as follows:

Two nodes $S_0$ and $S_1$ are connected if one polyomino contained in $S_1$ can be two-cut by an edge path $t_c$, so that the resulting polyomino set equals $S_0$.
This provides a perspective on the use of two-cuts and the way $G_{\textit{TCSA}}(\mathcal{T})$ is built starting with $\mathcal{T}$.
We will further explain the building process along with an example of a TCSA graph provided in \autoref{fig:tcsa}.


\paragraph{Building a TCSA Graph}

\autoref{algo:build_tcsa} describes the process of building $G_{\textit{TCSA}}(\mathcal{T})$ for the target $\mathcal{T}$.
The algorithm works through each newly added node in $V$ in a breadth-first-search manner.
The first node added to $V$ is $S_\mathcal{T}$, which is a polyomino set only containing the target polyomino.

New nodes and edges are determined by two-cutting every polyomino type $\mathcal{A}$ in the current set $S_i$ by every possible monotone two-cut of $\mathcal{A}$.
This is done by enumerating the two-cuts with {\scshape Two-Cuts}, the way it is described in \autoref{sec:twocutting}.
The cutting, done with {\scshape Cut-Polyomino}, results in the two sub-polyominoes $\mathcal{A}_1$ and $\mathcal{A}_2$.

$S_\textit{new}$ contains the same polyominoes as $S_i$ with the exception that one occurrence of $\mathcal{A}$ is removed and replaced by one occurrence of $\mathcal{A}_1$ and $\mathcal{A}_2$.
Each $S_\textit{new}$ is the result of cutting one polyomino of $S_i$ at a specific two-cut $t_c$.
If $S_\textit{new}$ is not already contained in $V$, it can be added, which also queues it for future iterations of the breadth-first-search.

No matter if $S_\textit{new}$ is contained in $V$ or not, an edge going from $S_\textit{new}$ to $S_i$ with $t_c$ as the weight is added to the edges $E$.
This allows multiple edges, as seen in \autoref{fig:tcsa_multiedge}, and multiple outgoing edges to different nodes, which can be observed in \autoref{fig:tcsa}, where different connections in $S_4$ lead to $S_1$ or $S_2$.

Each two-cut applied to a polyomino set increases its amount of polyominoes by one.
Let $n$ be the size of $\mathcal{T}$, then $n-1$ two-cuts applied to $S_\mathcal{T}$ will produce a polyomino set $S_\textit{trivial}$ containing $n$ trivial polyominoes, as it is the case for $S_7$ in \autoref{fig:tcsa}.
All $S_i$ will inevitably end up in this situation and the algorithm will return $\{V,E\}$, since trivial polyominoes cannot be cut anymore.

This implies that no matter which edges are chosen along the way, $n-1$ edges need to be traversed to get from $S_\textit{trivial}$ to $S_\mathcal{T}$.
We describe this attribute by giving the TCSA graph a depth of $n$.
The depth is also illustrated in \autoref{fig:tcsa} and the numbering of the nodes matches the order they were added by \autoref{algo:build_tcsa}.

\vspace{0.32em}

\begin{algorithm}
	\caption{$\text{\scshape Build-TCSA-Graph}$}
	\label{algo:build_tcsa}
	\begin{algorithmic}[1]
		\REQUIRE $\mathcal{T}$ \COMMENT{target polyomino}
		\ENSURE $G_{\textit{TCSA}}(\mathcal{T})$ \COMMENT{the graph is represented by nodes $V$ and edges $E$} 
		\STATE $\{V,E\} \gets \{\{\},\{\}\}$
		\STATE $i \gets 0$
		\STATE $V[i] \gets S_\mathcal{T}$ \COMMENT{start with set only containing $\mathcal{T}$}
		\WHILE[work through nodes in BFS manner]{$i < \text{\scshape Size}(V)$}
			\STATE $S_i \gets V[i]$
			\FOR[go through all polyomino types in $S_i$]{\textbf{each} $\mathcal{A} \in S_i$}
				\FOR[go through all monotone two-cuts]{\textbf{each} $t_c \in \text{\scshape Two-Cuts}(\mathcal{A})$}
					\STATE $\{\mathcal{A}_1, \mathcal{A}_2\} \gets \text{\scshape Cut-Polyomino}(\mathcal{A}, t_c)$
					\STATE $S_\textit{new} \gets \left( S_i \setminus \{\mathcal{A}\} \right) \cup \{\mathcal{A}_1, \mathcal{A}_2\}$ \COMMENT{new node after cutting}
					\IF{$S_\textit{new} \notin V$}
						\STATE $V \gets \text{\scshape Append}(V, S_\textit{new})$
					\ENDIF
					\STATE $E \gets \text{\scshape Append}(E, \{S_\textit{new}, t_c, S_i\})$
				\ENDFOR
			\ENDFOR
			\STATE $i \gets i+1$
		\ENDWHILE
		\RETURN $\{V,E\}$
	\end{algorithmic}
\end{algorithm}


\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{figures/plots/tcsa_nodes_edges.pdf}
	\caption[Average two-cut-sub-assembly nodes and edges for target size $n$]{Average number of nodes (left) and edges (right) of a TCSA graph for different target polyomino sizes $n$. For each size $200$ polyominoes were randomly generated. An exponential function is fitted over the averages of nodes and edges with a mean-squared error of $0.9999$ for both functions.}
	\label{fig:tcsa_plot}
\end{figure}

\subsection{Complexity}

The Stirling numbers of second kind provide an upper bound for the number of nodes in a TCSA graph.
The Stirling numbers of second kind
\begin{equation}
\bracenom{n}{k} = \sum_{i=1}^{k} \frac{(-1)^{k-i} \, i^{n-1}}{(i-1)! \, (k-1)!}
\end{equation}
describe the possibilities of sorting a set with $n$ objects into $k$ partitions \cite{jelliss1991}.
In our case, $n$ is the size of $\mathcal{T}$ and the number of partitions $k$ is the number of polyominoes the $n$ cubes belong to.
Different layers of depth account for different $\bracenom{n}{k}$.
$S_\mathcal{T}$ is the only polyomino set with $k=1$, so $\bracenom{n}{1} = 1$.
$S_\textit{trival}$ is the only set containing $k=n$ polyominoes, so $\bracenom{n}{n} = 1$.
For the maximum number of nodes possible, all layers of the TCSA graph have to be summed up by
\begin{equation}
|V|_\textit{worst} = \sum_{k=1}^{n} \bracenom{n}{k} \, .
\end{equation}
%which is also referred to as the Bell number \cite{jelliss1991}.

In our case, the only way of sorting cubes into partitions is by monotonously two-cutting existing polyominoes, which drastically lowers the number of $|V|_\textit{worst}$.
In \autoref{fig:tcsa_plot} statistical data shows the average number of nodes and edges a TCSA graph consists of for varying target polyomino sizes $n$.
The growth of nodes and edges seems to be exponential, which is shown with fitted functions in \autoref{fig:tcsa_plot}.
The mean-squared error of $0.9999$ for both functions was calculated with the python library scikit-learn\footnote{scikit-learn: \url{https://scikit-learn.org/}}.

Our implementation of $G_{\textit{TCSA}}(\mathcal{T})$ stores nodes in a hash-table.
Accessing nodes and connected edges, or checking if a polyomino set is contained in $G_{\textit{TCSA}}(\mathcal{T})$, can be done very efficiently.
The creation of $G_{\textit{TCSA}}(\mathcal{T})$ becomes more complex for increasing numbers of $n$, but it provides an easily accessible building instruction that drastically cuts the number of unnecessary local plans simulated.
Lowering simulation time makes a complex data structure like the TCSA graph worth the extra effort.

\newpage

\section{Connection Options}
\label{sec:connect_options}

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{figures/connect_options.pdf}
	\caption[Example of connection options for one two-cut-sub-assembly edge]{All connection options when connecting a red cube at the west edge of a blue cube to get from $S_7$ to $S_4$. Developing local plans for different polyomino pairs leads to different goal configurations. $(\mathcal{A}_1,\mathcal{B}_1)$ and $(\mathcal{A}_2,\mathcal{B}_1)$ lead to configurations with the desired polyomino set $S_4$, but $(\mathcal{A}_2,\mathcal{B}_2)$ leads directly to $S_2$. All of these sets can be found in the TCSA graph of \autoref{fig:tcsa}. The goal configuration of $(\mathcal{A}_1, \mathcal{B}_2)$ holds the set $S_\text{x}$, which cannot be found in \autoref{fig:tcsa}. This set could not be used for further global planning. For better readability, we used normal instead of calligraphic letters for polyominoes in this figure ($\mathcal{A}_1 = \text{A1}$).}
	\label{fig:connect_options}
\end{figure}

In each configuration $g$ that the global planner encounters, $G_{\textit{TCSA}}(\mathcal{T})$ will be used to determine the next connection that the local planner should try to establish.
Outgoing edges of $S(g)$ will be retrieved from the hash-table of $G_{\textit{TCSA}}(\mathcal{T})$.
If $S(g) \notin G_{\textit{TCSA}}(\mathcal{T})$, $g$ cannot be used to assemble $\mathcal{T}$.
This allows the global planner to state failure immediately when an initial configuration already contains sub-assemblies that are not usable for assembling $\mathcal{T}$.
With the exception of $S_\mathcal{T}$, all nodes have outgoing edges in a TCSA graph.
All outgoing edges of $S(g)$ provide connections for the local planner that bring the global planner closer to assembling $\mathcal{T}$.

For instance, if $S(g) = S_7$ in \autoref{fig:tcsa}, three outgoing edges provide three connections to choose from.
Multiple polyominoes of the same type produce even more options to consider.
Assume the global planner decides to connect a red cube at the west edge of a blue cube to end up in a configuration $g_2$ with $S(g_2) = S_4$.
Since $S_7$ contains two red and two blue cubes, there are four ways to achieve this.
\autoref{fig:connect_options} illustrates the four connection options for this example case.
For all four connection options, the local planner ended in different goal configurations.

Let $L_\mathcal{A}$ and $L_\mathcal{B}$ be collections of the physically distinct polyominoes for the polyomino types $\mathcal{A}$ and $\mathcal{B}$.
When $\mathcal{A}$ and $\mathcal{B}$ are about to be connected as the weight of a TCSA edge dictates, there are $\left| L_\mathcal{A} \times L_\mathcal{B} \right|$ polyomino pairs to choose from.
If $\mathcal{A} = \mathcal{B}$, the options where a polyomino will be connected with itself can be eliminated.

With multiple edges and various polyomino pairs per edge, many options emerge for the global planner to consider.
We examined three option sorting strategies, to provide an order of the best probable outcome that the global planner can work through. 
We define functions for determining the best option $\hat{o}$ out of two options $o_1$ and $o_2$.
The approaches are compared in \autoref{chap:results}.

%\newpage

\paragraph{Minimal Distance}

The minimal distance sorting sorts connection options based on the distance between the connection-cubes $c_\mathcal{A}$ and $c_\mathcal{B}$.
The idea is that a smaller distance requires less movement to establish a connection, which means shorter simulation time and lower plan cost.
Due to sliding on walls and different pivot walking distances, this is not true in every case, but it remains a good heuristic for sorting, because it is simple to compute.
Less movement might even prevent unwanted sub-assemblies.
\begin{equation}
\hat{o}(o_1, o_2) =
\begin{cases}
o_1 & \text{if } d(c_{\mathcal{A},1}, c_{\mathcal{B},1}) \leq d(c_{\mathcal{A},2}, c_{\mathcal{B},2}) \\
o_2 & \text{otherwise}
\end{cases}
\end{equation}


\paragraph{Grow Largest Component}

Another approach is to grow the largest component.
The options are sorted into classes of maximum polyomino size $\hat{n}$ of the resulting polyomino set.
TCSA edges that lead to sets containing the biggest polyominoes are preferred.
When the options for $S_4$ in \autoref{fig:tcsa} are sorted, the one leading to $S_1$ is preferred over the one leading to $S_2$, because $S_1$ contains a polyomino of size $3$, while $S_2$ only contains polyominoes of size $2$. 
The options within each class are sorted with the minimal distance approach.

If no other sub-assemblies occur, growing the largest component behaves like one-tile-at-a-time assembly \cite{Becker2020}.
The benefit is that even if sub-assemblies occur, the TSCA graph provides solutions to integrate them if possible.
Larger polyominoes generally move faster, acting positively on plan cost.
\begin{equation}
\hat{o}(o_1, o_2) =
\begin{cases}
o_1 & \text{if } \left( \hat{n}_1 > \hat{n}_2 \right) \lor \left( \left( \hat{n}_1 \equiv \hat{n}_2 \right) \land \left( d(c_{\mathcal{A},1}, c_{\mathcal{B},1}) \leq d(c_{\mathcal{A},2}, c_{\mathcal{B},2})\right)\right) \\
o_2 & \text{otherwise}
\end{cases}
\end{equation}

\paragraph{Grow Smallest Component}

Oppositely to growing the largest component, options can be sorted by the smallest maximum size of polyominoes in polyomino sets.
This avoids working with large polyominoes, which are faster, but also need more simulation time to perform rotations and can be hard to handle, because of sheer size.
\begin{equation}
\hat{o}(o_1, o_2) =
\begin{cases}
o_1 & \text{if } \left( \hat{n}_1 < \hat{n}_2 \right) \lor \left( \left( \hat{n}_1 \equiv \hat{n}_2 \right) \land \left( d(c_{\mathcal{A},1}, c_{\mathcal{B},1}) \leq d(c_{\mathcal{A},2}, c_{\mathcal{B},2})\right)\right) \\
o_2 & \text{otherwise}
\end{cases}
\end{equation}

%\newpage

\section{Use of Local Planner}
\label{sec:local_in_global}

The local planner develops plans for connections chosen from the different connection options presented in \autoref{sec:connect_options}.
For that, it needs only one edge-pair out of the connections stored in the weight of a TSCA edge.
Whenever a path consists of both north-south and east-west connections, a north-south connection is preferred.
This is done to perform offset-aligning instead of straight-aligning (\autoref{sec:align}) for an easier slide-in.
Besides that, the choice of connection is irrelevant, since all connections in the path lead to the same outcome.

When the local planner successfully connects the desired polyominoes, other sub-assemblies can lead to a different polyomino set than expected.
This is not necessarily bad, as long as the resulting set is contained in $G_{\textit{TCSA}}(\mathcal{T})$.
In fact, more sub-assemblies decrease the number of polyominoes in the workspace, which brings the goal of assembling $\mathcal{T}$ even closer.
Layers of depth were skipped in the TCSA graph, so that it might be possible to assemble $\mathcal{T}$ with less than $n-1$ local plans.
This can be seen in \autoref{fig:connect_options}, when $\mathcal{A}_2$ and $\mathcal{B}_2$ are connected. 
The resulting polyomino set matches with $S_2$ instead of $S_4$ of the nodes from \autoref{fig:tcsa}.

Like already mentioned in \autoref{sec:connect_options}, when the resulting polyomino set is not contained in $G_{\textit{TCSA}}(\mathcal{T})$, it is not possible to assemble the target from that configuration.
This can be seen in \autoref{fig:connect_options} when connecting $\mathcal{A}_1$ and $\mathcal{B}_2$.
For global use we add a new failure condition to the local planner, which frequently checks if the polyomino set of the configuration in the workspace is contained in $G_{\textit{TCSA}}(\mathcal{T})$.
If not, the local planner immediately states failure and avoids spending simulation time on a configuration with no further use.

\newpage

The local planner might even fail to establish the desired connection.
If the resulting polyomino set is contained in $G_{\textit{TCSA}}(\mathcal{T})$, global planning can continue, but there are certain failure types that are not valid for further planning.
Polyomino sets with invalid polyominoes, or where connections in caves are necessary, should not be present in the TCSA graph anyway.
We also do not continue planning with a failure due to maximum movement capacity or polyominoes being stuck (\autoref{sec:plan}).

\vfill

\begin{algorithm}
	\caption{\scshape Assemble-Target}
	\label{algo:global_algo}
	\begin{algorithmic}[1]
		\REQUIRE $\mathcal{T}$, $g_\textit{init}$ \COMMENT{target polyomino and intital configuration}
		\ENSURE $\{s,P\}$ \COMMENT{state of global plan $s$ and plan stack $P$ containing local plans}
		\STATE $\{s,P\} \gets \{\text{undefined}, \{\}\}$
		\STATE $g \gets g_\textit{init}$ \COMMENT{current configuration $g$}
		\STATE $G_{\textit{TCSA}}(\mathcal{T}) \gets \text{\scshape Build-TCSA-Graph}(\mathcal{T})$
		\LOOP
			\STATE $O \gets \text{\scshape Connection-Options}(g, G_{\textit{TCSA}}(\mathcal{T}))$
			\STATE valid $\gets$ \FALSE
			\WHILE[try options until local plan is valid]{\NOT $\text{\scshape Empty}(O)$ \AND \NOT valid}
				\STATE $(c_\mathcal{A}, c_\mathcal{B}, e_\mathcal{A}, e_\mathcal{B}) \gets \text{\scshape Pop}(O)$
				\STATE $p_\textit{new} \gets \text{\scshape Local-Planner}(g, (c_\mathcal{A}, c_\mathcal{B}, e_\mathcal{A}, e_\mathcal{B}), G_{\textit{TCSA}}(\mathcal{T}))$
				\IF{$\text{\scshape Valid-Plan}(p_\textit{new})$}
					\STATE valid $\gets$ \TRUE
				\ENDIF
			\ENDWHILE
			\IF{valid}
				\STATE $P \gets \text{\scshape Push}(P, p_\textit{new})$ \COMMENT{add new plan to plan stack}
				\STATE $g \gets g_\textit{goal}$ of new local plan $p_\textit{new}$ \COMMENT{move to new goal configuration}
				\IF[target got assembled]{$\mathcal{T} \in S(g)$}
					\STATE $s \gets \text{success}$
					\RETURN $\{s, P\}$
				\ENDIF
			\ELSE
				\IF[no configuration to fall back to]{$\text{\scshape Empty}(P)$}
					\STATE $s \gets \text{failure}$
					\RETURN $\{s, P\}$
				\ENDIF
				\STATE $p_\textit{pre} \gets \text{\scshape Pop}(P)$ \COMMENT{remove last plan from plan stack}
				\STATE $g \gets g_\textit{init}$ of last local plan $p_\textit{pre}$ \COMMENT{fall back to last initial configuration}
			\ENDIF
		\ENDLOOP
	\end{algorithmic}
\end{algorithm}

\newpage

\section{Global Planning Algorithm}
\label{sec:global_algo}

\autoref{algo:global_algo} takes the initial configuration $g_\textit{init}$ and the target $\mathcal{T}$ as inputs and returns the state of the global plan $s$ and a plan stack $P$ as outputs.
For a successful plan, $P$ contains the local plans leading to the assembly of $\mathcal{T}$.
Concatenating the actions of all the plans in $P$ creates a sequence of actions that forms the global plan.
Because the local plans were created using a TCSA graph, $|P| < n$ holds true (\autoref{sec:tcsa}).
The reason for $P$ being called a stack is the way it is used in \autoref{algo:global_algo}.

The algorithm explores the configuration-space along $G_{\textit{TCSA}}(\mathcal{T})$ in depth-first-search manner, which is done in an attempt to get closer to assembling $\mathcal{T}$ each iteration.
The algorithm starts with $g_\textit{init}$ as the current configuration $g$ and builds the TCSA graph for $\mathcal{T}$ with \autoref{algo:build_tcsa}.

As a first step of each iteration the connection options for $g$ are determined with {\scshape Connection-Options} as described in \autoref{sec:connect_options}.
The mechanism behind this function can be viewed as a hash-table, storing the options as values and using the configurations as keys.
The options need to be determined and sorted, but only the first time a configuration is encountered.
The list of connection options $O$ that {\scshape Connection-Options} provides is only a view on the values stored in the hash-table.
When $O$ is altered, the hash-table is updated as well.
Whenever a connection option is popped from $O$, the option is removed from the hash-table and will therefore never be considered again.

Note that options are stored per configuration $g$, not for the polyomino set $S(g)$.
Two configurations sharing the same polyomino set both have their own lists of connection options.
We explore the configuration-space with the TCSA graph as a guidance, not the TCSA graph itself.
Nodes in $G_{\textit{TCSA}}(\mathcal{T})$ can be encountered multiple times and will never be eliminated from planning.

Once the list of connection options $O$ is retrieved, the algorithm works through it in the order determined by the option sorting that was applied in advance.
This is done until a valid local plan is found, or no options are left.
{\scshape Local-Planner} uses \autoref{algo:local_algo} to create a local plan $p_\textit{new}$.
It also takes $G_{\textit{TCSA}}(\mathcal{T})$ as an input parameter, to ensure the newly added failure condition defined in \autoref{sec:local_in_global}.
The validity of a local plan is evaluated with {\scshape Valid-Plan}.

If a valid local plan is found, $p_\textit{new}$ is pushed on to $P$ and $g$ is set to the goal configuration of $p_\textit{new}$.
When a configuration containing $\mathcal{T}$ is reached, the global plan is successful and the algorithm returns.
On the other hand, if no valid option for $g$ can be found, the algorithm has to fall back to the last visited configuration.
For that, the top local plan $p_\textit{pre}$ on $P$ is popped and its initial configuration becomes the new $g$.
Even though $p_\textit{pre}$ was a successful local plan, it led to a dead end and had to be removed from the stack.
If $P$ is empty, the current configuration is $g_\textit{init}$.
This means that there is no previously visited configuration the algorithm can fall back to.
In that case the algorithm states failure for assembling $\mathcal{T}$.

Before calling \autoref{algo:global_algo}, it is necessary to check if $\mathcal{T} \in S(g_\textit{init})$ to state early success.
Furthermore, a timeout failure is added to \autoref{algo:global_algo} in case planning takes too long.
 
\subsection{Complexity}
\label{sec:global_complex}

\paragraph{Optimality}

Given that the local planner does not produce an optimal solution for the connection of two polyominoes, the global planner will also not reach optimality.
Even if the local planner provides only optimal solutions, our depth-first-search approach would not explore the configuration-space in a way that the best sequence of local plans is guaranteed to be picked.
\autoref{algo:global_algo} greedily moves along the depth of the TCSA graph to assemble the target as fast as possible.
The option sorting strategies provide reasonable heuristics for picking a connection option per individual TCSA node, but cannot ensure the optimal decision, let alone the optimal decision for the whole path of connection options chosen.
Optimal solutions need broad exploration and comparison of different paths to the target, which is infeasible in our case due to the high simulation time required for local plans.

\paragraph{Completeness}

In the same manner as with optimality, the local planner prevents the completeness of the global planner.
Assuming completeness of the local planner, the global planner could be certain of the existence or non-existence of a solution for assembling $\mathcal{T}$.
\autoref{algo:global_algo} will always return success or failure after simulating a finite amount of local plans.
This is due to the finite number of connection options per configuration and the depth $n$ of the TCSA graph.
Each local plan in the plan stack is certain to connect at least two polyominoes, even if it is a failure due to a wrong connection or an impossible slide-in.
After $n-1$ local plans the workspace contains only one $n$-size polyomino.
This polyomino is not necessarily $\mathcal{T}$, but no further connections can be made, which makes the algorithm fall back to the last configuration.
Together with the finite number of options per configuration, the algorithm will eventually explore all paths of connection options that are possible and can therefore verify the existence or non-existence of a solution.
Remember that this completeness is based purely on the strong assumption of a complete local planer, which is challenging to achieve in the special Euclidean group.

\paragraph{Efficiency}

We have to differentiate between local plans in the plan stack and local plans created during planning $\#\textit{local}$.
Even though $|P| < n$, the global planner might have developed more local plans which were either invalid or had to be removed because they led to a dead end.
In the best case, only one local plan could lead to the assembly of $\mathcal{T}$.
This is highly unrealistic, but theoretically possible since layers of depth in the TCSA graph can be skipped.
A more realistic best case would be $n-1$ local plans created during planning. 
This would assume that all local plans created are valid and lead directly to the target with no layer skipping.

In the worst case all paths of connection options have to be explored before stating failure.
In this worst case ``all'' means that each connection option at each configuration produces a valid local plan with no other sub-assemblies leading to a unique new configuration.
The only invalid local plans are the ones that lead to a configuration with one $n$-size polyomino that is not $\mathcal{T}$.

It is not possible to state the exact amount of worst case local plans, since the number of connection options per configuration varies.
By taking the average number of connection options per TCSA node $o_\mu$, we can define an estimate
\begin{equation}
\#\textit{local}_\textit{worst} = \sum_{i=1}^{n-1} {o_\mu}^i \, .
\end{equation} 
For $n = 10$ and $o_\mu = 20$ this results in $\#\textit{local}_\textit{worst} \approx 5 \cdot 10^{11}$.

It is impossible to simulate that many local plans in a reasonable time.
For that reason the timeout failure was added.
\autoref{chap:results} will provide experimental data on the number of $\#\textit{local}$ and what percentage of global plans time out.
The number of configurations explored $\#\textit{config}$ is also examined in the experiments to better portray the number of dead ends during planning.


\section{More Cubes than Target Size}
\label{sec:more_cubes}

For the global planner to work, the number of cubes in the workspace is limited to the target size $n$.
The reason for this is linked with the use of TCSA graphs.
Using a hash-table to find a TCSA node $S_\textit{TCSA}$ and checking for equality with the configuration's polyomino set $S(g)$ is simple and fast.
If a configuration holds more cubes than the TCSA nodes hold, we need to check if $S_\textit{TCSA} \subseteq S(g)$.
This cannot be done by hash comparing, so all nodes of the graph need to be checked, which would be very costly.
In addition to that, multiple nodes can be included in $S(g)$.
The global planner could handle this by summing up the connection options of all the nodes, but again this makes planning more complex and costly.

After assembling $\mathcal{T}$, all the leftover cubes could assemble various polyominoes.
We could enumerate all possible leftover polyomino sets $S_l$ and remove all of them separately from $S(g)$ to check for $S_\textit{TCSA} = S(g) \setminus S_l$.
This would again result in multiple nodes and summed up connection options, but with the ability to hash compare for equality.
The number of $S_l$ can become large for increasing numbers of leftover cubes, since $n$ leftover cubes can assemble all polyominoes of up to size $n$.
The amount of possible polyominoes for various sizes was enumerated in \cite{Lu2021}.
These large numbers lead to a less efficient global planner.



