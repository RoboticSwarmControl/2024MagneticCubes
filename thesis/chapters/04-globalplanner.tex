\chapter{Global Planner}
\label{chap:global}

The task of the global planner is to assemble a specified target polyomino $T$ given an initial configuration $g_{init}$.
The configuration-space is explored by executing local plans developed by the local planner from \autoref{chap:local}.
That way, the part of the configuration-space we can actually explore, is limited to configurations were a connection attempt between two cubes was made.
Compared to $SE(2)$ this part is manageable in size and only contains configurations which are interesting for self-assembly.

The question still remains, how these configurations are explored.
Using rapidly-exploring random trees (RRTs) \cite{lavalle1998} yields good results in a lot of cases, since the space gets evenly explored without the problematic of determining what decisions are promising for the end goal.
But, it also means the exploration of many configurations, which are not neccessary for reaching the goal.
For us this approach is not reasonable. 
Because of the high fidelity simulation we are working with, the computation time for a local plan is huge, so planning the assembly of $T$ with as less local plans as possible is the aim for our global planner.

We need to make well though-through connection decisions, that are valid for assembling $T$, meaning some sort of building plan for a polyomino is needed.
Creating a building sequences by removing one tile at a time from the target was done by Becker et al. \cite{Becker2020}.
However, this does not consider sub-assemblies, so all cubes that are not to be connected, have to stay separated at any time and occurring sub-assemblies would lead to immediate failure.

It is hard to prevent sub-assemblies, so our approach uses an enumeration of cutting a polyomino into two pieces (\autoref{sec:twocutting}), which will be used for generating a so called two-cut-sub-assembly graph (\autoref{sec:tcsa}).
In \autoref{sec:global_algo} that graph will be used as a building instruction along side the exploration of the configuration-space.
For this technique the number of cubes in the workspace is limited to the size of $T$.
A take on why is this done and why the problem becomes more complex when working with extra cubes, is done in \autoref{sec:more_cubes}.


\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{figures/twocuts.pdf}
	\caption[Different cuts for polyomino shapes]{Examples for cutting polyomino shapes. The top row shows three two-cuts for a $3\times3$ shape, of which only the left one is monotone and therefor valid. The middle one creates a cave and the right one a hole. The bottom row shows cuts that do not split the polyomino into two pieces. The right one creates three sub-polyominoes and the left one does not break the polyomino at all.}
	\label{fig:twocuts}
\end{figure}
%TODO make red line dashed

\section{Two-Cutting Polyominoes}
\label{sec:twocutting}

Schmidt et al. \cite{Schmidt2018} made use of straight-line two-cuts, to handle the construction of a polyomino with more than trivial sub-assemblies.

We define a two-cut as a continues path of connections through a polyomino, that divides the polyomino into two sub-polyominoes, when these connections would be removed.
For later use in \autoref{sec:tcsa} we want to enumerate all two-cuts of a polyomino that are useful for planning.
We do not limit the cuts by only allowing straight paths like \cite{Schmidt2018}, instead we only consider monotone two-cuts.

Monotone means, that whenever the path goes into a direction it can never go into the opposite direction again.
\autoref{fig:twocuts} top-left shows a monotone two-cut through a $3\times3$ polyomino shape.
The cut starts at the top of the shape and only moves down and right.s
By removing all the connections on the path, the polyomino shape is split into two pieces.
Considering non-monotone two-cuts would create sub-assemblies with caves or holes, which could no be reassembled with our local planner.
This is the reason why they are omitted on a global scale in advance.
\autoref{fig:twocuts} top-middle shows a non-monotone two-cut creating a cave and \autoref{fig:twocuts} top-right one creating a hole.

To calculate all two-cuts of a polyomino, we take all possible monotone paths from each connection as a starting point.
A path ends when it breaks out of the polyomino or into a hole.
After the path ended its connections are removed from the polyomino and the path is added as a two-cut, if the polyomino got split into exactly two pieces.
The bottom row of \autoref{fig:twocuts} shows cuts that split the polyomino in less or more than two pieces.

% 32 possibilities for 3x3

\begin{figure}
	\centering
	\includegraphics[width=0.45\textwidth]{figures/tcsa_multiedge.pdf}
	\caption[Two TCSA nodes connected with multiple edges.]{Two TCSA edges connecting the polyomino sets $S_0$ and $S_1$. The weights of the edges differ, since there are two ways to connect the $2\times1$ with the $1\times1$ to create a $3\times1$ polyomino. The connections are illustrated in rectangular boxes places on the edges.}
	\label{fig:tcsa_multiedge}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{figures/tcsa.pdf}
	\caption[Example for a two-cut-sub-assembly graph.]{Example of an TCAS graph for a four-cube L-shape. The polyomino sets are illustrated as ellipses. If the polyominoes of a set are not numbered, there is only one occurrence of this polyomino. Otherwise the number of occurrences is placed left of the polyomino. The sets are numbered, as if the graph was produces by \autoref{algo:build_tcsa}. The weight of edges are illustrated as rectangular boxes containing the polyominoes that need to be connected at specific edges, marked in yellow.}
	\label{fig:tcsa}
\end{figure}

\section{Two-Cut-Sub-Assembly Graph}
\label{sec:tcsa}

The two-cut-sub-assembly graph, short TCSA graph, functions as a building instruction for a specific target polyomino, we will call it $G_{TCSA}(T)$.
The TCSA graph works with sets of polyominoes as nodes.
While a configuration $g$ holds information about orientation and position of physically distinct polyominoes, the corresponding polyomino set $S(g)$ only enumerates the polyomino types preset in $g$.
If $g$ contain multiple polyominoes of the same type, $S(g)$ still stores the amount of the polyomino type, but does not distinguish between the actual polyominoes.

Two nodes $S_0$ and $S_1$ of the TSCA graph are connected with and edge $(S_0,w,S_1)$, if $S_0$ can be transformed to $S_1$ by connecting two polyominoes contained in $S_0$.
The cube and edge information of the connections are stored as the weight $w$.
$S_0$ and $S_1$ can be connected by multiple edges, if there are different connections that produce the same outcome.
The edges differ in their weights as shown in \autoref{fig:tcsa_multiedge}.
The direction of $e(S_0,S_1)$ always goes from $S_0$ to $S_1$, but we can reverse the definition for an edge as following:

Two nodes $S_0$ and $S_1$ are connected, if one polyomino contained in $S_1$ can be two-cut, so that the resulting polyomino set equals $S_0$.
This already provides a perspective on the use of two-cuts and the way $G_{TCSA}(T)$ is build purely based on $T$.
We will further explain the building process along with an example of a TCSA graph provided in \autoref{fig:tcsa}.


\begin{algorithm}
	\caption{\scshape Build-TCSA-Graph}
	\label{algo:build_tcsa}
	\begin{algorithmic}[1]
		\REQUIRE $T$
		\ENSURE $G_{TCSA}(T)$ \COMMENT{the graph is represented by nodes $V$ and edges $E$} 
		\STATE $V \gets \{\}$
		\STATE $E \gets \{\}$
		\STATE $i \gets 0$
		\STATE $V[i] \gets S_T$	\COMMENT{$S_T$ only contains $T$}
		\WHILE[work through nodes in BFS manner]{$i < \text{\scshape Size}(V)$}
			\STATE $S_i \gets V[i]$
			\FOR[go through all polyomino types in $S_i$]{$\forall P \in S_i$}
				\FOR{$\forall tc \in \text{\scshape Two-Cuts}(P)$}
					\STATE $P_1$,$P_2 \gets \text{\scshape Cut-Polyomino}(P, tc)$
					\STATE $S_{new} \gets S_i \setminus \{P\} \cup \{P_1, P_2\}$ \COMMENT{create $S_{new}$ by removing $P$ and adding $P_1$,$P_2$}
					\IF{$S_{new} \notin V$}
						\STATE $V \gets \text{\scshape Append}(V, S_{new})$
					\ENDIF
					\STATE $E \gets \text{\scshape Append}(E, (S_{new}, tc, S_i))$
				\ENDFOR
			\ENDFOR
			\STATE $i \gets i+1$
		\ENDWHILE
		\RETURN $(V,E)$
	\end{algorithmic}
\end{algorithm}


\paragraph{Building TCSA Graph}

\autoref{algo:build_tcsa} describes the process of building $G_{TCSA}(T)$ for the target $T$.
The algorithm works through each newly added node in $V$ in a breadth-first-search manner.
The first node added to $V$ is $S_T$, which is a polyomino set only containing the target shape.

New nodes and edges are determined, by two-cutting every polyomino type $P$ in the current set $S_i$ by every possible two-cut of $P$.
This is done by enumerating the two-cuts with {\scshape Two-Cuts}, the way it was described in \autoref{sec:twocutting}, and cutting $P$ at the two-cut with {\scshape Cut-Polyomino}.
The cutting results in the two sub-polyomino $P_1$ and $P_2$.
$S_{new}$ contains the same polyominoes as $S_i$ with the exception, that one occurrences of $P$ got removed and replaced by one occurrence of each $P_1$ and $P_2$.
Each $S_{new}$ is the result of cutting one polyomino of $S_i$ at a specific two-cut $tc$.
If $S_{new}$ is not already contained in $V$, we can add it to $V$ for future iterations of the breadth-first-search.

No matter if $S_{new}$ is contained in $V$ or not, an edge going from $S_{new}$ to $S_i$ with $tc$ as the weight is added to the graph edges $E$.
This allow multiple edges, as seen in \autoref{fig:tcsa_multiedge}, and multiple out going edges to different nodes, which can be observed in \autoref{fig:tcsa}, where different connections in $S_4$ lead to either $S_1$ or $S_2$.

Each two-cut applied to a polyomino set reduces its amount of polyominoes by one.
Let $n$ be the size of $T$, then $n-1$ two-cuts applied to $S_T$ will produce a polyomino set $S_{trivial}$ containing only trivial polyominoes, as it is the case for $S_7$ in \autoref{fig:tcsa}.
All $S_i$ will inevitably end up in this situation and the algorithm will return $(E,V)$, since trivial polyominoes can not be cut anymore.
This means that no matter which connections are chosen along the way, $n-1$ edges will always be needed to get from $S_{trivial}$ to $S_T$.
We describe this attribute, by giving the TCSA graph a depth of $n$.
The depth is also illustrated in \autoref{fig:tcsa} and the numbering of the nodes matches the way they got added by \autoref{algo:build_tcsa}.


\paragraph{Complexity}

% sterling numbers second kind as upper bound: find literatur
% connectivity cuts notes, monotonie cuts notes
% Access to graph in O(1) due to hash comparing.
% Creation complex but worth it -> minimize sim-time
% show practical data for tcsa-notes per size. Box-Whisker PLOT




\section{Global Planning Algorithm}
\label{sec:global_algo}

% provide algorith
% use of tcsa-graph
% limit number of cubes to target size
% check inclusion of poly set from config in tcsa-graph
% example early failure if initial is not in tcsa


\subsection{Connection Options}

% talk about options per note all edges to neighboring notes
% now consider position pairwise for all physical of poly types. example FIGURE
% taking a option with local planner
% - due to subassembly might not end in desired poly set
% - even local failure -> continue planning if poly set in graph
% - add allowed-poly failure to local planner to check this runtime
% - failure type that are not valid for further planning


\subsection{Option Sorting}

% there can be alot options
% we need smart decisions to pick best

\paragraph{Minimal Distance}

\paragraph{Grow Largest Component}
% this resembles one tile at a time with subassemblys still possible

\paragraph{Grow Smallest Component}



\subsection{Graph Traversal}

% DFS traversal. try to get to target as fast as possible
% Fall back if all options tried
% note that we not traverse tcsa graph we actually traverse configurations.
% When 2 configs with same polyset occure still try all options for both, because position differs

\paragraph{Complexity}

% best case 1 local plan. realistic best case n-1
% we are not limited by notes in tcsa, because n configs for 1 note
% for each note there is a constant number of options and depth smaller n-1.
% we wont run infinitly, but worst case is still bad. state example each note 50 options

\paragraph{Discretize Configurations}

% dont know if I wil actually implement, but talk about benefits or why not that neccessary




\section{More Cubes than Target}
\label{sec:more_cubes}

% bigger tcsa with multiple end notes
% same tcsa
% - no simple hash check. check for set inclusion
% - a poly set can be included in multiple tcsa-notes -> increasing options per config