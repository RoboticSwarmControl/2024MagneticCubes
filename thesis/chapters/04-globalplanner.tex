\chapter{Global Planner}
\label{chap:global}

The task of the global planner is to assemble a specified target polyomino $T$ given an initial configuration $g_{init}$.
The configuration-space is explored by executing local plans developed by the local planner from \autoref{chap:local}.
That way, the part of the configuration-space we can actually explore, is limited to configurations were a connection attempt between two cubes was made.
Compared to $SE(2)$ this part is manageable in size and only contains configurations which are interesting for self-assembly.

The question still remains, how these configurations are explored.
Using rapidly-exploring random trees (RRTs) \cite{lavalle1998} yields good results in a lot of cases, since the space gets evenly explored without the problematic of determining what decisions are promising for the end goal.
But, it also means the exploration of many configurations, which are not neccessary for reaching the goal.
For us this approach is not reasonable. 
Because of the high fidelity simulation we are working with, the computation time for a local plan is huge, so planning the assembly of $T$ with as less local plans as possible is the aim for our global planner.

We need to make well though-through connection decisions, that are valid for assembling $T$, meaning some sort of building plan for a polyomino is needed.
Creating a building sequences by removing one tile at a time from the target was done by Becker et al. \cite{Becker2020}.
However, this does not consider sub-assemblies, so all cubes that are not to be connected, have to stay separated at any time and occurring sub-assemblies would lead to immediate failure.

It is hard to prevent sub-assemblies, so our approach uses an enumeration of cutting a polyomino into two pieces (\autoref{sec:twocutting}), which will be used for generating a so called two-cut-sub-assembly graph (\autoref{sec:tcsa}).
In \autoref{sec:global_algo} that graph will be used as a building instruction along side the exploration of the configuration-space.
For this technique the number of cubes in the workspace is limited to the size of $T$.
A take on why is this done and why the problem becomes more complex when working with extra cubes, is done in \autoref{sec:more_cubes}.




\section{Two-Cutting Polyominoes}
\label{sec:twocutting}

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{figures/twocuts.pdf}
	\caption[Different cuts for polyomino shapes]{Examples for cutting polyomino shapes. The top row shows three two-cuts for a $3\times3$ shape, of which only the left one is monotone and therefor valid. The middle one creates a cave and the right one a hole. The bottom row shows cuts that do not split the polyomino into two pieces. The right one creates three sub-assemblies and the left one does not break the polyomino at all.}
	\label{fig:twocuts}
\end{figure}
%TODO make red line dashed

Schmidt et al. \cite{Schmidt2018} considered straight-line two-cuts to divide polyominoes into two sub-assemblies.
We define a two-cut as a continues path of connections through a polyomino, that divides the polyomino into two pieces, when these connections would be removed.
For later use in \autoref{sec:tcsa} we want to enumerate all two-cuts of a polyomino that are useful for planning.
We do not limit the cuts by only allowing straight paths like \cite{Schmidt2018}, instead we only consider monotone two-cuts.

Monotone meaning, that whenever the path goes into a direction it can never go into the opposite direction again.
\autoref{fig:twocuts} top-left shows a monotone two-cut through a $3\times3$ polyomino shape.
The cut starts at the top of the shape and only moves down and right.
By removing all the connections on the path, the polyomino shape is split into two pieces.
Considering non-monotone two-cuts would create sub-assemblies with caves or holes, which could no be reassembled with our local planner.
\autoref{fig:twocuts} top-middle shows a non-monotone two-cut creating a cave and \autoref{fig:twocuts} top-right one creating a hole.

To calculate all two-cuts of a polyomino, we take all possible monotone paths from each connection as a starting point.
A path ends when it breaks out of the polyomino or into a hole.
After the path ended its connections are removed from the polyomino and the path is added as a two-cut, if the polyomino got split into exactly two pieces.
The bottom row of \autoref{fig:twocuts} shows cuts that split the polyomino in less or more than two pieces.

% 32 possibilities for 3x3



\section{Two-Cut-Sub-Assembly Graph}
\label{sec:tcsa}

\begin{figure}
	\centering
	\includegraphics[width=1.00\textwidth]{figures/tcsa.pdf}
	\caption[Example for a two-cut-sub-assembly graph.]{long caption...}
	\label{fig:tcsa}
\end{figure}

% short TCSA-Graph
% purpes of this -> building sequence to target
% considering sets of polyominoes no positions in workspace
% notes are polysets edges connect polysets with (cube, cube, edge) conection as weigth. directiong from twocut to connected

\paragraph{Building TCSA-Graph}

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{figures/tcsa_multiedge.pdf}
	\caption[Two TCSA nodes with multiple edges.]{long caption...}
	\label{fig:tcsa_multiedge}
\end{figure}

% provide algorithm
% explain procedure with special cases
% - endup at all trivial
% - depth of graph n
% - common predecessor
% - multiple edges for same notes -> example FIGURE 3x1 + 1x1 = 4x1
% big example FIGURE of TCSA graph should include all special cases

\paragraph{Complexity}

% sterling numbers second kind as upper bound: find literatur
% connectivity cuts notes, monotonie cuts notes
% Access to graph in O(1) due to hash comparing.
% Creation complex but worth it -> minimize sim-time
% show practical data for tcsa-notes per size. Box-Whisker PLOT




\section{Global Planning Algorithm}
\label{sec:global_algo}

% provide algorith
% use of tcsa-graph
% limit number of cubes to target size
% check inclusion of poly set from config in tcsa-graph
% example early failure if initial is not in tcsa


\subsection{Connection Options}

% talk about options per note all edges to neighboring notes
% now consider position pairwise for all physical of poly types. example FIGURE
% taking a option with local planner
% - due to subassembly might not end in desired poly set
% - even local failure -> continue planning if poly set in graph
% - add allowed-poly failure to local planner to check this runtime
% - failure type that are not valid for further planning


\subsection{Option Sorting}

% there can be alot options
% we need smart decisions to pick best

\paragraph{Minimal Distance}

\paragraph{Grow Largest Component}
% this resembles one tile at a time with subassemblys still possible

\paragraph{Grow Smallest Component}



\subsection{Graph Traversal}

% DFS traversal. try to get to target as fast as possible
% Fall back if all options tried
% note that we not traverse tcsa graph we actually traverse configurations.
% When 2 configs with same polyset occure still try all options for both, because position differs

\paragraph{Complexity}

% best case 1 local plan. realistic best case n-1
% we are not limited by notes in tcsa, because n configs for 1 note
% for each note there is a constant number of options and depth smaller n-1.
% we wont run infinitly, but worst case is still bad. state example each note 50 options

\paragraph{Discretize Configurations}

% dont know if I wil actually implement, but talk about benefits or why not that neccessary




\section{More Cubes than Target}
\label{sec:more_cubes}

% bigger tcsa with multiple end notes
% same tcsa
% - no simple hash check. check for set inclusion
% - a poly set can be included in multiple tcsa-notes -> increasing options per config