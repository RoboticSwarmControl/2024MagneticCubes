\chapter{Simulator}
\label{chap:sim}

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{figures/simulator_controlflow.pdf}
	\caption[Control flow of the simulator]{long caption...}
	\label{fig:simulator}
\end{figure}

Our simulator used for modeling the behavior of magnetic modular cubes uses the 2d physics library Pymunk\footnote{Pymunk: \url{https://www.pymunk.org/}}.
This library is build for the Python 3 and Python 2 environment based on the 2d physics library Chipmunk\footnote{Chipmunk: \url{http://chipmunk-physics.net/}}.
We used Pymunk, since it can be easily integrated and customized in a Python implementation.
Furthermore it is light-weight and capable of running headless, but also offers an interface for Pygame\footnote{Pygame: \url{https://www.pygame.org/}}, which we use to visualize developed plans and allowing user controls.
As a disadvantage, we are challenge with the simulation of 3d movement in a 2d environment.
That way we trade simulation accuracy for faster simulation time, which is necessary to develop global plans in a reasonable time.

\autoref{fig:simulator} shows a flow chart diagram of the simulators simulation loop.
The diagram provides the control flow of our simulator, where individual steps are explained in this and following sections.

Any control program, in example a local planner or a ``sandbox program'' for visually controlling magnetic modular cubes with keyboard inputs, can interact with the top-level interface of the simulator.
The interface provides functionalities like, starting and stopping the simulation process, controlling the drawing with Pygame, or loading custom configurations and retrieving the current workspace state (\autoref{sec:workspace_state}).
Another crucial functionality is queuing in motions for simulation and notifying the control program, when a motion is done simulating.
After handling the motion control, further explained in \autoref{sec:motion_control}, the simulator enters the Pymunk-step.

The Pymunk-step is a library function, responsible for updating the simulation environment by a certain time step.
The duration of a time step is a parameter that allows adjustment between simulation accuracy and simulation time. 
Inside the Pymunk-step forces are applied to the cubes and collision with workspace boundaries and between cubes is handled (\autoref{sec:coll_handling}).

After the Pymunk-step the magnetic forces between permanent magnets of cubes are calculated, which also determines connections of cube faces used to retrieve information about the polyominoes present in the workspace (\autoref{sec:force_magnet}).
Polyominoes are necessary to calculate the force of the magnetic field acting on cubes (\autoref{sec:force_field}) and friction forces, on which we heavily rely to simulate 3d movement like pivoting on pivot edges (\autoref{sec:force_friction}).
All the calculated forces will be applied in the Pymunk-step in the next iteration of the simulation loop.

When drawing is enabled the Pygame-rendering of the workspace is the last step before beginning the next iteration.

% plot of time use for simulation

\section{Motion Control}
\label{sec:motion_control}

The motion control manages the queued in motions from the control program and determines an update of the magnetic field for each iteration of the simulation loop.
This update consists of the longitude change in radians and the latitude change called the elevation.
In our simulator the elevation just states if the magnetic north points up, the magnetic south points up, or the magnetic field latitude lays in a neutral position within the workspace plane.
We do not specify a angular value of the latitude, since we cannot model it in the 2d-environment anyway.
The elevation just indicates the simulator to simulate pivoting of polyominoes.
More on that in \autoref{sec:force_friction}.

A change of elevation is executed in a single iteration, but the angle of a rotation will be simulated by multiple longitude changes in a linear ramp with a rotational velocity we choose to set to $\frac{\pi}{8} \, \text{rad}/\text{s}$.
Each motion will be simulated by applying its sequence of updates.
After that, the control program is notified.
This makes closed loop control possible by waiting until motions are done.

These updates control the magnetic field orientation and not magnetic modular cubes directly.
Cubes will orient themselves by magnetic field forces we further explain in \autoref{sec:force_field}.
The larger a polyomino is, the more time it needs to align with the magnetic field, which can take longer than rotating the magnetic field itself.
A certain amount of zero-updates is appended to a rotations update sequence depending on the size of the larges polyomino in the workspace.
That way the control program will not be notified until all polyominoes are aligned with the magnetic field.
For this reason simulating larger polyominoes requires more simulation time due to more iterations of the simulation loop.

\section{Workspace State}
\label{sec:workspace_state}

The state of the workspace is stored and updated within the Pymunk-space.
By saving a configuration of the workspace, relevant attributes like position, orientation and velocity of cubes are copied from the Pymunk-space.
These Pymunkt-space attributes will be manipulated when loading in a configuration.

Furthermore a configuration stores magnetic field orientation and the polyominoes, together with their center of mass and pivot points, that got detected by our polyomino detection method elaborated in \autoref{sec:force_magnet}.
Polyominoes are stored in a custom data structure that functions both as a list of physical polyominoes and a polyomino set for the use in two-cut-sub-assembly graphs (\autoref{sec:tcsa}).
The data structure and the polyominoes themselves are hashable for fast equality and inclusion checks.

Individual orientation and velocities of cubes will not be used for planning, but they ensure a correct loading of a workspace configuration that got saved while in motion or when cubes where not or not yet aligned with the magnetic field.
The alignment can be prevented by walls or other cubes, even though we assume perfect alignment with the magnetic field during planning.

\section{Collision Handling}
\label{sec:coll_handling}

Collision is detected and resolved by Pymunk during the Pymunk-step.
For the collision detection Pymunk uses a bounding volume hierarchy of objects in the Pymunk-space.
We also use this efficient collision detection for determining cube pairs in critical-distance.
For that, each cube is surrounded by a circular sensor with half the critical-distance as the radius.
Cubes are in critical-distance if two sensors collide.
Cubes not in critical-distance are to far away to significantly affect each other with magnetic forces of their permanent magnets.
We only calculate magnet forces for cube pairs in critical-distance to speed up simulation.
We set the critical-distance to be $5 r_C$.

\section{Simulating Forces}


% apply with pymunk

\begin{figure}
	\centering
	\includegraphics[width=0.6\textwidth]{figures/plots/magnet_force.pdf}
	\caption[Force between magnets of two cubes for distance.]{long caption...}
	\label{fig:magnet_force}
\end{figure}

\subsection{Magnet Forces}
\label{sec:force_magnet}

% pull cubes together
% provide equation
% plot for magnetic attraction based on distance
% hold cubes together -> polyomino detection
% wich magnetic pairs to choose
% minDist, minDists, all

\subsection{Magnetic Field Forces}
\label{sec:force_field}

% applied to top bottom each indivial cube
% as long as orientation doenst match
% the bigger the poly the longer rotations actually take 
% adding zero updates to motion so that motion finishes when polys oriented


\subsection{Friction Forces}
\label{sec:force_friction}

% force to let poly rotate around pivot point
% splitt friction on cubes on pivot edge
% nominal friction to prevent breaking


